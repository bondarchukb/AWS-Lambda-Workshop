================================================================================
         AWS LAMBDA WORKSHOP - PRESENTER SCRIPT (1 HOUR)
         For Python Developers
================================================================================

================================================================================
[0:00 - 0:05] INTRODUCTION & SETUP CHECK (5 min)
================================================================================

[0:00] WELCOME
-------
"Welcome everyone to the AWS Lambda Workshop! Today we're going to go from
zero to deploying Lambda functions using four different methods - all in
one hour. This is a fast-paced, hands-on session, so make sure you have
your terminals ready."

"By the end of this workshop, you'll be able to deploy Lambda using:
 - AWS Console (for learning and debugging)
 - AWS CLI (for scripting and automation)
 - AWS CDK with Python (for Infrastructure as Code)
 - And test locally using SAM CLI (before you deploy anything)"

[0:01] WHAT IS AWS LAMBDA? (Quick Overview)
-------
"For those who need a quick refresher - AWS Lambda is a serverless compute
service. You upload your code, and AWS handles everything else - servers,
scaling, patching, availability."

"Key points to remember:
 - You pay only for what you use (per millisecond)
 - It scales automatically from 0 to thousands of concurrent executions
 - No servers to manage
 - Supports Python, Node.js, Java, Go, .NET, Ruby, and custom runtimes"

"Lambda is event-driven - it runs in response to triggers like HTTP requests,
file uploads to S3, messages in a queue, or scheduled events."

[0:03] SETUP CHECK
-------
"Before we dive in, let's make sure everyone has the required tools.
Open your terminal and run these commands:"

"Check AWS CLI: aws --version - you need version 2"
"Check SAM CLI: sam --version"
"Check Python: python3 --version - 3.11 or higher"
"Check CDK: cdk --version"
"Check Docker: docker --version"

"Most importantly, verify your AWS credentials:"
"aws sts get-caller-identity"

"You should see your account ID and user ARN. If you get an error,
your credentials aren't configured correctly."

[0:05] "Any issues? No? Great, let's start deploying!"

================================================================================
[0:05 - 0:15] PART 1: AWS CONSOLE DEPLOYMENT (10 min)
================================================================================

[0:05] NAVIGATING TO LAMBDA
-------
"Let's start with the AWS Console. This is the visual way to create Lambda
functions. It's great for learning and quick debugging, but not for
production deployments."

"Open your browser, go to the AWS Console, and search for Lambda."

[0:06] CREATING A FUNCTION
-------
"Click 'Create function'. You'll see three options:
 - Author from scratch - what we'll use
 - Use a blueprint - pre-built templates
 - Container image - for Docker-based functions"

"Select 'Author from scratch' and configure:
 - Function name: workshop-console-demo
 - Runtime: Python 3.12
 - Architecture: x86_64 (default is fine)"

"Notice at the bottom - AWS automatically creates an execution role for you.
This role gives Lambda permission to write logs to CloudWatch."

"Click 'Create function'."

[0:08] WRITING THE CODE
-------
"Now you see the Lambda console. Scroll down to the code editor."

"Replace the default code with this simple handler:"

   import json

   def lambda_handler(event, context):
       print(f"Event: {json.dumps(event)}")

       return {
           'statusCode': 200,
           'body': json.dumps({
               'message': 'Hello from Console Lambda!',
               'input': event
           })
       }

"Let me explain what's happening here:
 - 'event' is the input data - could be from API Gateway, S3, SQS, etc.
 - 'context' contains runtime information - function name, memory, time remaining
 - We return a dictionary with statusCode and body - standard format for API responses"

"Click 'Deploy' to save your changes."

[0:10] TESTING THE FUNCTION
-------
"Now let's test it. Click the 'Test' tab."

"Create a new test event:
 - Event name: test1
 - Use the default JSON or type: {\"name\": \"Workshop\"}"

"Click 'Test'."

"You should see:
 - Execution result: succeeded
 - The response body with our message
 - Duration, billed duration, and memory used"

[0:12] VIEWING LOGS
-------
"Click on the 'Monitor' tab, then 'View CloudWatch logs'."

"This opens CloudWatch Logs. Every print() statement and every error
ends up here. This is your primary debugging tool in production."

"Notice each invocation gets its own log entry with:
 - START - with the request ID
 - Your print statements
 - END - with the request ID
 - REPORT - with duration, memory, and billing info"

[0:14] KEY TAKEAWAYS
-------
"The Console is great for:
 - Learning how Lambda works
 - Quick debugging and testing
 - One-off functions"

"But it's NOT good for:
 - Production deployments (no version control)
 - Team collaboration
 - Repeatable infrastructure"

"That's why we need CLI and Infrastructure as Code. Let's move on!"

================================================================================
[0:15 - 0:30] PART 2: AWS CLI DEPLOYMENT (15 min)
================================================================================

[0:15] WHY CLI?
-------
"The AWS CLI lets you do everything the Console does, but from the terminal.
This means you can script it, automate it, and put it in CI/CD pipelines."

"Let's create a new Lambda function using only CLI commands."

[0:16] CREATING THE IAM ROLE
-------
"First, Lambda needs an IAM role to execute. Let's create one."

"Create a file called trust-policy.json with the trust relationship:"

   {
     "Version": "2012-10-17",
     "Statement": [{
       "Effect": "Allow",
       "Principal": {"Service": "lambda.amazonaws.com"},
       "Action": "sts:AssumeRole"
     }]
   }

"This policy says: 'Lambda service is allowed to assume this role.'"

"Now create the role:"
   aws iam create-role \
     --role-name workshop-lambda-role \
     --assume-role-policy-document file://trust-policy.json

"Attach the basic execution policy for CloudWatch Logs:"
   aws iam attach-role-policy \
     --role-name workshop-lambda-role \
     --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

"Get the role ARN - you'll need this:"
   aws iam get-role --role-name workshop-lambda-role --query 'Role.Arn' --output text

"Save that ARN somewhere - we'll use it in a moment."

[0:19] CREATING THE FUNCTION CODE
-------
"Now let's write our Lambda function. Create a file called lambda_function.py:"

   import json
   from datetime import datetime, timezone

   def lambda_handler(event, context):
       print(f"Event: {json.dumps(event)}")

       return {
           'statusCode': 200,
           'body': json.dumps({
               'message': 'Hello from CLI Lambda!',
               'timestamp': datetime.now(timezone.utc).isoformat()
           })
       }

"For CLI deployment, we need to zip our code:"
   zip function.zip lambda_function.py

"This creates a deployment package. For Python, the zip file must contain
your .py files at the root level."

[0:22] DEPLOYING THE FUNCTION
-------
"Now the magic command - create the function:"

   aws lambda create-function \
     --function-name workshop-cli-demo \
     --runtime python3.12 \
     --handler lambda_function.lambda_handler \
     --zip-file fileb://function.zip \
     --role arn:aws:iam::YOUR_ACCOUNT:role/workshop-lambda-role

"Let me break down these parameters:
 - function-name: the name of your function
 - runtime: python3.12
 - handler: FILE.FUNCTION - lambda_function.py file, lambda_handler function
 - zip-file: fileb:// means 'binary file' - important!
 - role: the ARN we saved earlier"

"You should see a JSON response with your function configuration."

[0:24] INVOKING THE FUNCTION
-------
"Let's call our function:"

   aws lambda invoke \
     --function-name workshop-cli-demo \
     --payload '{"name": "CLI Workshop"}' \
     response.json

"Then view the response:"
   cat response.json

"You should see our message and timestamp. The invoke command writes
the response to a file - that's what response.json is for."

[0:26] UPDATING CODE AND CONFIGURATION
-------
"Made changes to your code? Update it like this:"

   zip function.zip lambda_function.py
   aws lambda update-function-code \
     --function-name workshop-cli-demo \
     --zip-file fileb://function.zip

"Need to change memory or timeout?"
   aws lambda update-function-configuration \
     --function-name workshop-cli-demo \
     --memory-size 256 \
     --timeout 10

"This increases memory to 256MB and timeout to 10 seconds."

[0:28] DEPLOYING WITH DEPENDENCIES
-------
"What if your function needs external packages like 'requests'?"

"Create requirements.txt:"
   requests==2.31.0

"Install to a package directory:"
   pip install -r requirements.txt -t package/

"Copy your lambda file into the package directory:"
   cp lambda_function.py package/

"Create the deployment package from inside the package folder:"
   cd package && zip -r ../function.zip . && cd ..

"This bundles your dependencies with your code - everything at the root
level of the zip, which is what Lambda expects. For larger dependencies,
use Lambda Layers instead - we'll mention that in the cheat sheet."

[0:29] KEY TAKEAWAYS
-------
"CLI is great for:
 - Scripting and automation
 - CI/CD pipelines
 - Quick updates and testing
 - When you need programmatic control"

"But for complex infrastructure with multiple resources, you want
Infrastructure as Code. That's where CDK comes in!"

================================================================================
[0:30 - 0:45] PART 3: AWS CDK WITH PYTHON (15 min)
================================================================================

[0:30] WHAT IS CDK?
-------
"AWS CDK - Cloud Development Kit - lets you define cloud infrastructure
using real programming languages. No more YAML or JSON templates!"

"As Python developers, you'll love this. You write Python code, CDK
generates CloudFormation, and deploys it. You get:
 - Type checking and IDE autocomplete
 - Loops, conditions, and functions
 - Reusable constructs
 - Proper version control"

[0:32] INITIALIZING THE PROJECT
-------
"Let's create a CDK project:"

   mkdir workshop-cdk && cd workshop-cdk
   cdk init app --language python

"This creates a Python project structure. Now activate the virtual environment:"
   source .venv/bin/activate  # On Mac/Linux
   # .venv\Scripts\activate   # On Windows

"Install the dependencies:"
   pip install -r requirements.txt
   pip install aws-cdk-lib constructs

[0:34] PROJECT STRUCTURE
-------
"Let's look at what CDK created:
 - app.py - the entry point
 - workshop_cdk/ - your stack definitions
 - cdk.json - CDK configuration"

"The main file we'll edit is workshop_cdk/workshop_cdk_stack.py"

[0:35] CREATING THE LAMBDA CODE
-------
"First, create a directory for our Lambda code:"
   mkdir lambda

"Create lambda/handler.py:"

   import json
   from datetime import datetime, timezone

   def handler(event, context):
       return {
           'statusCode': 200,
           'headers': {'Content-Type': 'application/json'},
           'body': json.dumps({
               'message': 'Hello from CDK Lambda!',
               'path': event.get('path', '/'),
               'timestamp': datetime.now(timezone.utc).isoformat()
           })
       }

[0:37] WRITING THE CDK STACK
-------
"Now the exciting part - defining our infrastructure in Python!"

"Edit workshop_cdk/workshop_cdk_stack.py:"

   from aws_cdk import (
       Stack,
       Duration,
       CfnOutput,
       aws_lambda as _lambda,
       aws_apigateway as apigw,
   )
   from constructs import Construct

   class WorkshopCdkStack(Stack):
       def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
           super().__init__(scope, construct_id, **kwargs)

           # Lambda Function
           fn = _lambda.Function(
               self, 'WorkshopFunction',
               runtime=_lambda.Runtime.PYTHON_3_12,
               handler='handler.handler',
               code=_lambda.Code.from_asset('lambda'),
               memory_size=256,
               timeout=Duration.seconds(10),
               environment={
                   'ENVIRONMENT': 'workshop'
               }
           )

           # API Gateway
           api = apigw.LambdaRestApi(
               self, 'WorkshopApi',
               handler=fn,
               proxy=True,
           )

           # Output the API URL
           CfnOutput(
               self, 'ApiUrl',
               value=api.url,
               description='API Gateway URL',
           )

"Let me walk through this:
 - We import CDK constructs for Lambda and API Gateway
 - _lambda.Function creates our Lambda with all configuration
 - apigw.LambdaRestApi creates an API Gateway that triggers our Lambda
 - CfnOutput prints the API URL after deployment"

"Notice how readable this is compared to CloudFormation YAML!"

[0:41] DEPLOYING WITH CDK
-------
"First, let's see what CDK will create:"
   cdk synth

"This generates the CloudFormation template. You can inspect it in cdk.out/"

"Check what will change:"
   cdk diff

"Now deploy:"
   cdk deploy

"CDK will show you the IAM changes and ask for confirmation. Type 'y'."

"Wait for deployment... and you'll see the API URL in the outputs!"

[0:43] TESTING THE API
-------
"Copy the API URL from the output and test it:"
   curl https://xxxxx.execute-api.us-east-1.amazonaws.com/prod/

"You should see our JSON response. We just deployed a Lambda with
API Gateway in about 20 lines of Python code!"

[0:44] CLEANUP
-------
"To delete everything:"
   cdk destroy

"CDK removes all resources it created. Clean and simple."

[0:45] KEY TAKEAWAYS
-------
"CDK is great for:
 - Complex infrastructure with multiple resources
 - Team collaboration with code reviews
 - Reusable patterns and constructs
 - Type safety and IDE support"

"Use CDK when you have real infrastructure to manage.
Use CLI for quick scripts and simple automation."

================================================================================
[0:45 - 0:55] PART 4: LOCAL TESTING WITH SAM (10 min)
================================================================================

[0:45] WHY LOCAL TESTING?
-------
"Before we deploy anything, we should test locally. This:
 - Saves time (no waiting for deployments)
 - Saves money (no AWS charges)
 - Catches bugs early
 - Speeds up development"

"AWS SAM CLI lets you run Lambda functions on your machine using Docker."

[0:46] INITIALIZING SAM PROJECT
-------
"Let's create a SAM project:"
   sam init --runtime python3.12 --name workshop-sam --app-template hello-world

"Select the default options. Then:"
   cd workshop-sam

"SAM creates a complete project structure:
 - hello_world/app.py - your Lambda code
 - hello_world/requirements.txt - dependencies
 - template.yaml - SAM/CloudFormation template
 - events/ - sample test events
 - tests/ - unit tests"

[0:48] BUILDING THE APPLICATION
-------
"Before running locally, build the application:"
   sam build

"This:
 - Installs dependencies from requirements.txt
 - Prepares your code for execution
 - Creates a .aws-sam directory with the build artifacts"

"If you have dependencies that need compilation (like numpy), use:"
   sam build --use-container

"This builds inside a Docker container matching the Lambda environment."

[0:50] LOCAL INVOKE
-------
"Now let's run our function locally:"
   sam local invoke HelloWorldFunction -e events/event.json

"This:
 - Starts a Docker container with the Lambda runtime
 - Loads your code
 - Passes the event from event.json
 - Returns the response"

"You can also pass events inline:"
   echo '{"name": "Test"}' | sam local invoke HelloWorldFunction --event -

[0:52] LOCAL API
-------
"Want to test with HTTP requests? Start a local API Gateway:"
   sam local start-api

"This starts a server on localhost:3000. In another terminal:"
   curl http://localhost:3000/hello

"You get the same response as if it were deployed! The first request
is slow because Docker needs to start, but subsequent requests are fast."

[0:53] GENERATING TEST EVENTS
-------
"SAM can generate sample events for different AWS services:"

   sam local generate-event apigateway aws-proxy > events/api.json
   sam local generate-event s3 put > events/s3.json
   sam local generate-event sqs receive-message > events/sqs.json

"These are realistic event payloads you can use for testing."

[0:54] DEPLOYING FROM SAM
-------
"When you're ready to deploy:"
   sam deploy --guided

"This walks you through:
 - Stack name
 - Region
 - Confirm changes
 - Save configuration for next time"

"Subsequent deployments are just:"
   sam deploy

"And cleanup:"
   sam delete

[0:55] KEY TAKEAWAYS
-------
"SAM CLI is essential for:
 - Local development and debugging
 - Testing before deployment
 - Generating sample events
 - Quick iteration cycles"

"Always test locally first, then deploy. Your AWS bill will thank you!"

================================================================================
[0:55 - 1:00] WRAP-UP & RESOURCES (5 min)
================================================================================

[0:55] QUICK RECAP
-------
"Let's recap what we covered:

1. Console - Visual, great for learning, not for production
2. CLI - Scriptable, great for automation and CI/CD
3. CDK - Infrastructure as Code in Python, great for complex setups
4. SAM - Local testing, essential for development

Each tool has its place:
 - Learning/debugging: Console
 - Quick scripts: CLI
 - Production infrastructure: CDK
 - Development workflow: SAM"

[0:57] COMPARISON TABLE
-------
"Quick comparison:

| Method  | Best For              | IaC | Local Test |
|---------|-----------------------|-----|------------|
| Console | Learning, debugging   | No  | No         |
| CLI     | Scripts, CI/CD        | No  | No         |
| CDK     | Complex infra         | Yes | No         |
| SAM     | Serverless apps       | Yes | Yes        |

In real projects, you'll often combine these:
 - CDK for infrastructure
 - SAM for local testing
 - CLI for quick operations"

[0:58] CLEANUP REMINDER
-------
"Don't forget to clean up your resources!

   aws lambda delete-function --function-name workshop-console-demo
   aws lambda delete-function --function-name workshop-cli-demo
   cd workshop-cdk && cdk destroy
   cd workshop-sam && sam delete

And delete the IAM role:
   aws iam detach-role-policy --role-name workshop-lambda-role \
     --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
   aws iam delete-role --role-name workshop-lambda-role"

[0:59] RESOURCES & NEXT STEPS
-------
"For further learning:

 - AWS Lambda Python Docs: docs.aws.amazon.com/lambda/latest/dg/lambda-python.html
 - Lambda Powertools: docs.powertools.aws.dev/lambda/python/
   (Amazing library for logging, tracing, and metrics)
 - Serverless Patterns: serverlessland.com/patterns
 - CDK Workshop: cdkworkshop.com

I've also provided a cheat sheet with all the commands we used today,
plus many more for production use."

[1:00] CLOSING
-------
"Thank you for attending! You now know four different ways to deploy
AWS Lambda functions. Start with Console for learning, use CLI for
automation, CDK for infrastructure, and always test locally with SAM."

"Any questions?"

================================================================================
                           END OF PRESENTER SCRIPT
================================================================================


================================================================================
                              TIPS FOR PRESENTER
================================================================================

BEFORE THE WORKSHOP:
 - Test all commands in your AWS account
 - Have the cheat sheet open in another tab
 - Pre-create the IAM role to save time if needed
 - Have backup screenshots in case of demo failures

TIMING TIPS:
 - If running behind, skip the "Deploy with Dependencies" section in CLI part
 - If running ahead, show more CloudWatch Logs features
 - The CDK section can be shortened by using pre-written code

COMMON ISSUES:
 - "Access Denied" - Check IAM permissions and credentials
 - "Role not found" - IAM role creation takes a few seconds to propagate
 - "Docker not running" - SAM local needs Docker Desktop running
 - "cdk bootstrap" - May need to run this first if new account/region

ENGAGEMENT IDEAS:
 - Ask "Who has used Lambda before?" at the start
 - Have attendees predict what each command will do
 - Share your screen AND the commands in chat
 - Pause for questions after each section

================================================================================
